# Modeling Overview

## Introduction

+ Represent geometrical information about objects.
  - Mainly shape.
  - Physical properties like material too, etc.
+ Two main types of 3D representations:
  - Volume.
  - Surface.
+ Volume representations:
  - Capture solid properties of the object.
  - Capture the volume occupied by the object.
  - Common in other disciplines.
  - Useful in some animation/rendering algorithms.
+ Surface representations:
  - Most common in Computer Graphics.
+ Three types of operations:
  - Evaluation:
    * Produce points on surface, sampling the surface.
    * Done when drawing it.
  - Query:
    * Determine information about a surface or solid. (is a point inside/outside?).
    * Distance to an object (collision detection).
    * Useful in some animation algorithms.
  - Modification:
    * Change the shape of an object.
    * Important in the construction of objects.
    * Interactively edit or modify the shape of an object.
    * Used in animation for objects that change shape.
    * Most difficult and challenging operation.

## Surfaces

+ Orientable 2D continuous **Manifold** embedded in $\R^3$.
  - Has inside and outside.
  - No infinitely thin parts.
  - Not divided into separate pieces.
  - For parameterized surfaces, the parameter space is continuous.
  - Points within a small sphere on the surface are generated by a
    similarly small surface in parameter space.
    * If the parameter values are close together, the surface points will also
      be close together.
+ Some algorithms cannot deal with non-manifold surfaces.
  - Issues with locality, may not be well-defined.
+ Can be a problem for Query and Modification operations.
+ Two main types of surface representations:
  - Parametric.
  - Implicit.
+ Surfaces of 3D objects are really 2D.

+ Parametric Surfaces:
  - Define a 2D coordinate space: the parameter space $(\vec{u}, \vec{v})$.
  - Points on the surface then become:
    $$
    x = X(u, v) \\
    y = Y(u, v) \\
    z = Z(u, v)
    $$
  - Usually restrict u, v to $0 \le u, v < 1$
  - Parameterizations are an approximation.
    * Good for a small part of the surface, less so for the whole thing.
  - Parameterizations are not unique.
  - Easy to draw.
  - Query operations can be somewhat difficult.

+ Piecewise Parametric Surfaces:
  - Can have parameter space for entire surface.
    * Plus mapping to the local parameter spaces for each of the pieces.
  - Use simple primitives to build up complex surfaces
    * Algorithms work on the primitives, so they can be simpler.

+ Implicit Surfaces:
  - A point on the surfaces satisfies: $f(x, y, z) = 0$.
    * $< 0$ inside the object, $> 0$ outside the object.
  - Harder to enumerate points on the surface for drawing.
  - Very good for query operations.
  - Often constructed from volumetric data.
    * Usually in form of isosurfaces, the collection of points that have the
      same value. SDFs!
  - Usually converted to a parametric representation for display.
  
+ Algorithms to convert between Parametric and Implicit representation exist.
  - Not always exact.
+ Sphere example:
  - Implicit: $x^2 + y^2 + z^2 - R^2 = 0$
  - Parametric:
    $$
    x = R cos\phi sin\theta \\
    y = R sin\phi sin\theta \\
    z = R cos\theta
    $$

## Polygons

+ Can have both implicit and parametric.
+ Not typically stored this way.
+ Has a plane equation which can be computed from its vertices.
  - Only triangles are guaranteed to be planar.
+ **Polygon Soup** - Unstructured list of verticies.
  - Possibly with a plane equation and material information.
  - The overall surface doesn't need to be continuous or manifold.
  - Waste of space verticies can be stored many times.
  - No connectivity information.
+ Verticies are typically stored in CCW order.
+ **Indexed Face Set**:
  - Two tables, one for verticies and one for faces (polygons).
  - Vertex Table:
    * One entry per vertex.
    * Stores coordinates.
    * May store normal, material, etc information.
  - Fate Table:
    * Stores index into the vertex table.
  - Basic connectivity info can be calculated.
    * Not efficiently.
  - To convert polygon soup:
    * Iterate verticies.
    * Store in vertex table. (uniquely)
    * Store indicies in face table.
  - Most common data structure.

## Differential Geometry

Starting with 2D curves:
+ A parameterized 2D curve $f(u)$ can be decomposed into $x(u)$ and $y(u)$.
+ The tangent to the curve is the _first_ derivative of $f$ with respect to $u$.
  - $f'(u) = (x'(u), y'(u))$
  - This is a directional vector in the direction the curve is moving.
  - Can calculate the normal to the curve at $u$/($x$, $y$).
+ The tangent vector allows for measuring the length of the curve.
  - It points along the curve over an infinitely small length.
  - Integrate the length of the tangent vector over the desired parameter values.
    * [0, 1] for the length of the entire curve.
    * **Arc length** is when you integrate over [0, u].
    * Arc length can be computed from any curve parameterization.
+ The number of line segments needed to accurately approximate the curve
  depends on how fast the tangent is changing.
  - This is the derivative of the tangent: **curvature**.
  - $k(s) = ||f''(s)||$
    * _Where $s$ is the arc length_.
  - A larger curvature requires more line segments.
+ In summary, you need 3 things to accurately render curves:
  - The tangent.
  - The normal.
  - The curvature.

## Differential Geometry (Surfaces)

+ We now have two parameters $u, v$.
+ Surface points are:
  $$
  f(u, v) = (x(u, v), y(u, v), z(u, v))
  $$
+ Parameter space is now a 2D grid evenly spaced in $u$ and $v$.
+ A straight line in $u$ or $v$ maps onto a _curve_ in 3D space.
  - No constraints on it.
  - Doesn't need to align with a coordinate axis.
+ We now have tangent vectors along both $u$ and $v$ directions.
  - These can be viewed as tangent vectors along two curves:
  $$
  C_u(t) = f(u_0 + t, v_0) \text{and} C_v(t) = f(u_0, v_0 + t)
  $$
  - For an arbitrary direction $\vec{w}$ (in parameter space):
  $$
  C_w(t) = f(u_0 + tw_u, v_0 + tw_v)
  $$

```admonish warning
No more math because it is unlikely to be on the test and would take for ever
to make notes.
```

+ The tangent vector in the chosen parameter direction $\vec{w}$ can be
  calculated by multiplying the Jacobian ($J$) with the direction vector.
  - The Jacobian is a matrix of partial derivatives.
  - Column-wise, its partial derivatives for each component of $\vec{w}$ with
    respect to a parameter.
+ $J$ is called the metric of the surface.
  - It converts from parameter space to surface space.
+ The normal vector can now be computed easily:
  - $ \frac{f_u \times f_v}{||f_u \times f_v||}$
+ The cosine of the angle between to vectors and parameter space can be given by:
  $\vec{a}^T \vec{b}$.
+ The angle between them on the surface would be:
  $(J\vec{a})^T(J\vec{b}) = \vec{a}^T(J^T J)\vec{b}$
  - $J^T J$ has a special form called the first fundamental form.
+ Issues begin with curvature.
  - There are multiple types of curvature.
  - You can get different curvatures depending on the exact direction $\vec{w}$
    that you follow.
  - There are four types mentioned in the slides:
    * Maximum curvature, the biggest.
    * Minimum curvature.
    * Mean curvature, average of min and max.
    * Gaussian, product of min and max.

## Curves

+ Like polygons, use many curves to make a bigger curve.
+ The individual curves are simpler.
+ Joined curves should look smooth, like one continuous curve.
  - Requires extra contstraints at join points.

## Continuity

+ A curve is $C^0$ continuous if all pieces join at their endpoints.
  - e.g. $c_1(1) = c_2(0)$
  - Not guaranteed to be smooth.
  - Want at least $C^0$.
+ A curve is $C^1$ continuous if the first derivatives are equal across the joins.
+ A curve is $C^n$ continuous if the first n derivatives are equal.
+ Usually interested in $C^1$ and $C^2$ curves.
+ Parameterization of curves can cause continuity issues.
  - Derivatives might point in the same direction, but their magnitude may differ.
  - Consider geometric continuity to allow for this difference.
+ Curves are $G^1$ continuous if they satisfy: $c_1'(1) = kc_2'(0)$
  - $k$ is a scalar constant.
  - This definiton extends to $G^n$.
+ $ C^n$ continuous $\rArr G^n$ continuous.

## Polynomials

$$f(t) = \sum^n_{i=0} a_i t^i$$
+ One way to represent curves called the canonical form.
  - $a_i$ is a vector.
  - Good for computation, not much else.
+ Need a way to obtain coefficients from the geometry/points.
+ A second way to represent curves: $f(t) = \sum^n_{i=0} c_i b_i(t)$
  - $c_i$ is a vector.
  - $b_i$ are polynomials called basis/blending functions.
  - Can choose blending functions in a convenient way.
    * i.e. To make it easy to fit the curve.
+ Examples:
  - Linear: $f(u) = a_0 + u a_1$
  - How do you derive $a_i$?
  - If $p_0$ and $p_1$ are the end points of the linear curve(line):
    * You can use: $f(u) = (1 - u)p_0 + u p_1$.
    * Or: $f(u) = p_0 + (p_1 - p_0) u$.
  - Basis functions aren't unique.
+ In the above example, $p_0$ and $p_1$ are called control points.
+ The choice of control points is not unique:
  - Could have chosen the mid point and one end point.
  - One end point and the vector to the other end point.
+ Different control points result in different blending functions.
+ But the same canonical representation.
+ We can use both representations to find $a_i$:
  - Continuing the example:
  $$
  a_0 = p_0 \\
  a_1 = p_1 - p_0
  $$
> This part is the part that makes sens:
+ In general:
  - $p_0$ is the value of $f(0)$ and $p_1$ is the value of $f(1)$.
  - Set up a system of equations:
  $$
  p_0 = f(0) = a_0 + 0 \cdot a_1
  p_1 = f(1) = a_0 + 1 \cdot a_1
  $$
  - put it into matrix form resulting in $p = Ca$.
    * Note: The matrix encodes the various blending functions.
  - $C$ is the constraint matrix.
  - Take $B = C^{-1}$ to get the blending matrix $B$:
  - $C^{-1} p = C^{-1}Ca \rarr C^{-1} p = a$
+ The canonical representation is now $f(u) = uBp$.
  - This technique is independent of the polynomial degree.

## Cubic Curves

+ High enough degree to produce smooth curves.
+ Low enough degree to be controllable.

## Continuity Again

+ With piecewise curves:
  - Each segment has parameter values 0 to 1.
  - The whole curve has parameter values 0 to $n$.
    * One global parameter space.
    * $n$ local parameter spaces.
+ In parameter space, there are values where one curve stops and the next begins.
  - Called **knots**.
+ How do we ensure a level of continuity across knots?
+ One solution: _shared (control) point scheme_.
  - The control point at the end of one piece is the control point at the start
    of the next piece.
    * Pieces need to be defined in terms of the values at their end points.
    * In general, too restrictive.
+ Next solution: _dependency scheme_.
  - Copy values at the end of one piece to the start of the next.
  - Can just evaluate the point at the end of the previous piece and use it as
    the start of the next.
+ Third solution: Use an explicit equation to connect two pieces.
  - Could be a constraint on the control points, or on the curve value at
    particular points.
+ Note: Solutions introduce connections of sort between the pieces, so a change
  in one can propagate along the curve.
+ This is referred to as **Local Control**.

## Local Control

+ Want Local Control.
  - i.e. Only affect a small number of pieces.

## Basis Conversion

+ The canonical representation can be used to convert between different types
  of control points.
+ Given a set of control points, multiply by the blending matrix to get the
  cononical polynomial.
+ Then multiply by the constraint matrix of a different representation to get
  its corresponding control points.

## Curved Surfaces

+ For curves, we have 4 control points for cubic curves.
+ For 3D bicubic polynomials (cubic polynomials in both parameters), there will
  be 16 coefficients.
  - Therefore 16 control points.
+ 2 parameter vectors.
+ Can use the same blending matrix as in the 2D: $A = BPB^T$
  - $A$ and $P$ hold the coefficients and control points.
+ To construct the surface: $f(u, v) = UBPB^TV^T$
+ For Bezier surfaces:
  - The four corners of the matrix are the four corner points on the surface.
  - The remaining points along the edges define the bezier curves that are the
    edge of the surface patch.
  - The 4 points in the middle control the curvature in the middle of the surface.
+ Continuity is similar as with 2D:
  - Control points along connecting edges must be the same (value) for $C^0$.
  - For $G^1$ they must be collinear (1st derivative is pointing in the same direction).
  - For $C^1$ they (1st derivative) must have same magnitude.
